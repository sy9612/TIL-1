---
typora-root-url: ..\image
typora-copy-images-to: ..\image
---

# Java

https://asfirstalways.tistory.com/158

네트워크상에서 쓸 수 있는 **객체지향 프로그래밍 언어**

- JVM만 설치하면 컴퓨터의 운영체제에 상관없이 작동(운영체제에 독립적)
- 기본 자료형을 제외한 모든 요소를 객체로 표현
- 캡슐화, 상속, 다형성
- GC를 통한 메모리 관리
- 멀티쓰레드 지원



### 객체지향 프로그래밍(OOP)

Object-Oriented Programming

- 데이터를 객체로 취급하여 프로그램에 반영
- 객체와 객체의 상호작용을 통해 프로그램이 동작하는 것을 말함

###### 객체지향 프로그래밍 특징

- 코드 재사용성이 높음
- 코드의 변경이 용이
- 직관적인 코드 분석
- 개발속도 향상
- 상속을 통한 장점 극대화



### JVM(Java Virtual Machine)

물리적 머신과 유사한 머신을 소프트웨어로 구현한 것

- 자바 애플리케이션을 클래스 로더를 통해 읽어들여 자바 API와 함께 실행하는 것
- JAVA와 OS사이에서 중개자 역할 수행 -> JAVA가 OS가 구애받지 않고 재사용을 가능하게 해줌
- 메모리관리, GC 수행
- 스택기반의 가상 머신

###### 실행과정

1. 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로하는 **메모리 할당**
   - JVM은 메모리를 용도에 따라 여러 영역으로 나누어 관리
2. 자파 컴파일러(javac)가 **자바 소스코드(.java)**를 읽어들여 **자바 바이트코드(.class)**로 변환

3. **Class Loader**를 통해 class 파일들을 JVM으로 로딩
4. 로딩된 class 파일들은 **Execution Engine**을 통해 해석
5. 해석된 바이트코드는 **Runtime Data Areas**에 배치되어 실질적인 수행이 이루어짐
   - JVM은 필요에 따라 Thread Synchronization과 같은 GC 관리 작업 수행

![image-20210427003429497](../image/image-20210427003429497-1619451350681.png)

- Class Loader

  JVM내 클래스(.class파일)을 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈

  Runtime시 동적으로 클래스 로드

  jar파일 내 저장된 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제함

  런타임에 참조

  > 클래스를 처음 참조할 때, 해당 클래스를 로드하고 링크함

- Execution Engine

  클래스를 실행함

  클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드 배치 -> 실행 엔진에 의해 실행

  **자바 바이트 코드**: 기계가 수행할 수 있는 언어보다 비교적 인간이 보기 편한 형태로 기술된 것

  바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경

  > 인터프리터
  >
  > - 자바 바이트 코드를 명령어 단위로 읽어서 실행
  > - 한 줄 씩 수행함 -> 느림

  > JIT(Just - In - Time)
  >
  > - 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일 -> **네이티브 코드로 변경**
  > - 인터프리팅 X -> 네이티브 코드로 직접 실행
  > - 네이티브코드: 캐시에 보관, 컴파일된 코드는 빠르게 새훙
  > - 한 번만 실행되는 코드라면 컴파일대신 인터프리팅이 유리(JIT 컴파일러는 컴파일 과정이 인터프리터보다 오래 걸림)
  > - JVM 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크, 일정 정도를 넘을 때만 컴파일 수행



#### Garbage Collector

GC를 수행하는 모듈 (쓰레드) 존재 (뒤에 자세히 후술)





## Runtime Data Area

프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간

![image-20210427003345102](..\image\image-20210427003345102.png)

- PC Register

  Thread가 시작될 때 생성되며 생성될 때마다 생성되는 공간으로 스레드마다 하나씩 존재

  Thread가 어떤 명령으로 실행해야 할 지 대한 기록을 하는 부분으로 **현재 수행중인 JVM 명령의 주소**를 가짐

- JVM 스택 영역

  프로그램 실행 과정 중 **임시로 할당**되었다가 메소드가 빠져나가면 **바로 소멸되는 특성**의 데이터를 저장하는 영역

  각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장

  메소드 호출 시마다 각각의 스택 프레임이 생성 -> 수행이 끝나면 프레임별로 삭제 -> 메소드 안에서 사용되는 값들(local variable) 저장

  호출된 메소드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장

- Native Method stack

  자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역

  JAVA가 아닌 **다른 언어로 작성된 코드**를 위한 공간

  JAVA Native Interface를 통해 **바이트 코드로 전환**하여 저장

  일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역

  C code를 실행시켜 Kernel에 접근

- **Method Area** (= Class area = Static area)

  클래스 데이터를 위한 공간

  클래스 정보를 처음 메모리 공간에 올릴 때 **초기화되는 대상을 저장하기 위한 메모리 공간**

  자바 프로그램은 main 메소드의 호출로부터 계속된 메소드의 호출로 흐름을 이어감

  대부분 인스턴스의 생성도 메소드 내에서 명령하고 호출

  **Runtime Constant Pool** 별도의 관리 영역도 함께 존재

>  ###### 올라가는 정보의 종류
>
>  - Field information
>
>    멤버변수의 이름, 데이터 타입, 접근 제어자에 대한 정보
>
> - Method Information
>
>    메소드의 이름, 리턴 타입, 매개 변수, 접근제어자에 대한 정보
>
>- Type Information
>
>    class 인지 interface인지의 여부 저장 / Type의 속성, 전체 이름, super class의 전체 이름(interface, object 제외)

- **Heap**

  객체를 위한 공간

  new 연산자로 생성된 객체와 배열을 저장

  class area 영역에 올라온 클래스들만 객체로 생성

![image-20210427003300089](..\image\image-20210427003300089.png)

> - Permanent Generation
>
>   생성된 객체들의 정보의 주소값이 저장된 공간
>
>   Class loader에 의해 load되는 Class, Method 등에 대한 meta 정보가 저장되는 영역, JVM에 의해 사용
>
>   Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용
>
> - New/Young 영역
>
>   - Eden: 객체들이 최초로 생성되는 공간
>   - Survivor 0 / 1: Eden에서 참조되는 객체들이 저장되는 공간
>
> - Old 영역
>
>   New area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간 Eden 영역에 객체가 가득차게 되면 첫번째 GC 발생
>
>   Eden 영역에 있는 값들을 Survivor 1 영역에 복사하고 이 영역을 제외한 나머지 영역의 객체 삭제

​		인스턴스 소멸 방법과 소멸 시점이 지역 변수와 다름 -> 힙 영역에 별도로 저장





### Collection

인터페이스를 기준으로 여러 구현체 존재

다수의 Data를 다루는 데 표준화된 클래스들을 제공 -> 데이터구조를 직접 구현하지 않고 편하게 사용할 수 있기 때문

객체를 보관하기 위한 공간을 미리 정하지 않음 -> 객체의 수를 동적으로 정함

- List
  - ArrayList
   - 검색으 용이 but 삽입, 삭제는 불편  
  - LinkedList
- Map
  - HashMap
  - LinkedHashMap: 순서 보장
- Set
  - HashSet
  - LinkedHashSet: 순서 보장
- Stack / Queue




